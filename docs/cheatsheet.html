<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Cheatsheet</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">dtype-next</span> <span class="project-version">6.01-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="buffered-image.html"><div class="inner"><span>Buffered Image Support</span></div></a></li><li class="depth-1  current"><a href="cheatsheet.html"><div class="inner"><span>Cheatsheet</span></div></a></li><li class="depth-1 "><a href="datatype-to-dtype-next.html"><div class="inner"><span>Why dtype-next?</span></div></a></li><li class="depth-1 "><a href="dimensions-bytecode-gen.html"><div class="inner"><span>Dimensions and Bytecode Generation</span></div></a></li><li class="depth-1 "><a href="overview.html"><div class="inner"><span>Overview</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tech</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>v3</span></div></div></li><li class="depth-3"><a href="tech.v3.datatype.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>datatype</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.argops.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>argops</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.bitmap.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bitmap</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.datetime.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>datetime</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.errors.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>errors</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.ffi.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ffi</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.functional.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>functional</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.jna.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jna</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.list.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>list</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.mmap.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mmap</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.mmap-writer.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mmap-writer</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.native-buffer.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>native-buffer</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.nippy.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>nippy</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.packing.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>packing</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.reductions.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>reductions</span></div></a></li><li class="depth-4"><a href="tech.v3.datatype.rolling.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rolling</span></div></a></li><li class="depth-3"><div class="no-link"><div class="inner"><span class="tree" style="top: -486px;"><span class="top" style="height: 495px;"></span><span class="bottom"></span></span><span>libs</span></div></div></li><li class="depth-4 branch"><a href="tech.v3.libs.buffered-image.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>buffered-image</span></div></a></li><li class="depth-4"><a href="tech.v3.libs.neanderthal.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>neanderthal</span></div></a></li><li class="depth-3"><div class="no-link"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>parallel</span></div></div></li><li class="depth-4"><a href="tech.v3.parallel.for.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>for</span></div></a></li><li class="depth-3"><a href="tech.v3.tensor.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>tensor</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.tensor.color-gradients.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>color-gradients</span></div></a></li><li class="depth-4"><a href="tech.v3.tensor.dimensions.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dimensions</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#cheatsheet" name="cheatsheet"></a>Cheatsheet</h1>
<p>The old cheatsheet has been moved to <a href="https://cnuernber.github.io/dtype-next/overview.html">overview</a>.</p>
<p>Most of these functions are accessible via the <code>[tech.v3.datatype :as dtype]</code> namespace. When another namespace is required, it is specified separately.</p>
<h2><a href="#containers" name="containers"></a>Containers</h2>
<p>Containers are mutable storage of primitive datatypes.</p>
<ul>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var-make-container">make-container</a> - make a native heap or java heap based container.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var-make-list">make-list</a> - make a new efficient implementation of PrimitveList that stores data  in a single contigous container. Analog of java.util.ArrayList.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var-clone">clone</a> - Clone efficiently copies the data into a new container.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var-copy.21">copy!</a> - Copy data between containers.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var-coalesce.21">coalesce!</a> - Coalesce a sequence of containers of data into one pre-sized container.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.mmap.html#var-mmap-file">tech.v3.datatype.mmap/mmap-file</a> - MMap a file, returning a native heap based  container.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var-elemwise-datatype">elemwise-datatype</a> - Get the datatype of this buffer.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var-ecount">ecount</a> - the count of elements in the object. This function returns a long (as  opposed to int), is extensible to new objects and works on more objects than  <code>clojure.core.count</code>.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var-shape">shape</a> - Return the ND shape of the object.</li>
</ul>
<h2><a href="#getting-a-buffer-reader" name="getting-a-buffer-reader"></a>Getting a Buffer/Reader</h2>
<p>The buffer abstraction is the base efficient random access read/write abstraction available in the library. Most operations are implemented in terms of buffers. Readers are buffers that do not support write - <code>(= false (.supportsWrite buf))</code>. Readers and Buffers implement Indexed and IFn interfaces so they can be used as functions of their indexes, be destructured, and used with <code>nth</code>. Nearly anything can be turned into a reader - persistent vectors, java arrays, anything deriving from both java.util.List and java.util.RandomAccess or anything in-place convertible to a java array or a native buffer.</p>
<ul>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var-as-buffer">as-buffer</a>, <a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var--.3Ebuffer">-&gt;buffer</a> - type hinted to return a <a href="https://github.com/cnuernber/dtype-next/blob/d04c309bd565292c1c3d9880b4bbb80b6ff9478e/java/tech/v3/datatype/Buffer.java">Buffer</a>. <code>as-buffer</code> can return nil.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var-as-reader">as-reader</a>, <a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var--.3Ereader">-&gt;reader</a> - type hinted to return a Buffer. <code>as-reader</code> can return nil.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var-elemwise-cast">elemwise-cast</a> - Perform a checked runtime cast operation upon read and advertise  a new datatype to the system.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var-const-reader">const-reader</a> - Create a new buffer of a given length that always returns a const  value.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var-make-reader">make-reader</a> - Create (reify) a new reader of a given datatype. User provides inline  code that converts from <code>idx</code> to a correctly typed value. The ND analogue of this  function is <code>compute-tensor</code>.</li>
</ul>
<h2><a href="#getting-a-known-container-type" name="getting-a-known-container-type"></a>Getting a Known Container Type</h2>
<ul>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var--.3Earray">-&gt;array</a>, <a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var--.3Ebyte-array">-&gt;(*)-array</a> Convert to a java array of a known datatype.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var-as-array-buffer">as-array-buffer</a>, <a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var--.3Earray-buffer">-&gt;array-buffer</a> - Convert to an ‘array-buffer’ a generalized  (allows sub-buffer) concrete type used for all java arrays.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var-as-native-buffer">as-native-buffer</a>, <a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var--.3Enative-buffer">-&gt;native-buffer</a> - Convert to a native buffer. This pathway  forms the basis for numpy/julia ND integrations.</li>
</ul>
<h2><a href="#manipulating-buffers" name="manipulating-buffers"></a>Manipulating Buffers</h2>
<p>We provide a few simple base methods to interact with buffers. These will automatically convert their input to a buffer so <code>-&gt;buffer</code> is not required.</p>
<ul>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var-indexed-buffer">indexed-buffer</a> - Return a new buffer indexed via the integer indexes provided.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var-concat-buffers">concat-buffers</a> - in-place concatenate buffers. Sometimes it will be faster to just  create a new container.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var-sub-buffer">sub-buffer</a> - Take a contiguous range of indexes and return a new buffer that shares  the underlying backing store.</li>
</ul>
<h2><a href="#lazy-elementwise-operations" name="lazy-elementwise-operations"></a>Lazy Elementwise Operations</h2>
<p>Elemwentwise operations are lazily done upon read of the index and are not cached. They are instant on large vectors but to ‘realize’ the operation into a new container you will need to use ‘clone’ or ‘copy!’. This allows chaining together multiple elementwise operations into one concrete parallelized operation at runtime – this is a cheap, simple form of ‘combining kernels’ that takes advantage of quick vtable calls in order to be efficient. When high-performance matters, there are simple pathways to <a href="https://github.com/cnuernber/dtype-next/blob/d04c309bd565292c1c3d9880b4bbb80b6ff9478e/test/tech/v3/tensor/integration_test.clj#L49">inline operations</a> and from there to hand-written code that is as efficient as possible on the jvm.</p>
<ul>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.html#var-emap">emap</a> - elemwise-map a function that performs the mapping upon each elemwise read  returning a new reader.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.functional.html">tech.v3.datatype.functional</a> - Namespace of elementwise operations along  with a few reductions. <code>dfn</code> also includes a few descriptive statistics operations.</li>
</ul>
<h2><a href="#index-space-operations" name="index-space-operations"></a>Index Space Operations</h2>
<p>Working in index space is often the most efficient way to work as it involves operations tailored to either <code>:int32</code> (int) or <code>:int64</code> (long) values and sets of values. These operations form a primary technical facility used by tech.ml.dataset. All of these operations are found in <code>tech.v3.datatype.argops</code>. All of these operations return indexes that point to the query results and are meant to be used in conjunction with <code>indexed-buffer</code> in order to re-index the underlying data.</p>
<ul>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.argops.html#var-argmin">argmin</a>, <a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.argops.html#var-argmax">argmax</a> - (serial) index of last min element, index of last max element.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.argops.html#var-binary-search">binary-search</a> - (serial) return index of insert position for element. May return  n-elems in the case the element greater than any elements in the input data.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.argops.html#var-argfilter">argfilter</a> - (parallel) - return a container of indexes that filter the data  according to filter-fn.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.argops.html#var-argsort">argsort</a> - (parallel) - return of container of indexes that sort the data.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.argops.html#var-arggroup">arggroup</a>, <a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.argops.html#var-arggroup-by">arggroup-by</a> - (parallel) - Highly optimized method to return an implementation of  java.util.Map where the keys are the result of group-fn and the values are a  container of indexes of the respective source elements.</li>
</ul>
<h2><a href="#high-performance-aggregations" name="high-performance-aggregations"></a>High Performance Aggregations</h2>
<p>These reductions are designed to allow a relatively simple api to high performance group-by type operations that are useful to aggregate data. These provide a lower level interface to allow direct aggregations as opposed to the index-space aggregations of <code>tech.v3.datatype.functional/arggroup-by</code>. These are found in the <code>tech.v3.datatype.reductions</code> namespace.</p>
<ul>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.reductions.html#var-ordered-group-by-reduce">ordered-group-by-reduce</a>, <a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.reductions.html#var-unordered-group-by-reduce">unordered-group-by-reduce</a> - Reduce data into either a  java.util.HashMap (ordered) or java.util.concurrent.ConcurrentHashMap (unordered)  via transformation provided via the provided <a href="https://github.com/cnuernber/dtype-next/blob/d04c309bd565292c1c3d9880b4bbb80b6ff9478e/java/tech/v3/datatype/IndexReduction.java">IndexReduction</a>. Note this interface provides both a per-index call called in each cpu thread and an aggregate-reduction call to merge the per-thead contexts.</li>
</ul>
<h2><a href="#high-performance-parallelization-primitives" name="high-performance-parallelization-primitives"></a>High Performance Parallelization Primitives</h2>
<p>We attempt to provide a simple, axiomatic set of primitives to perform as efficient of a reduction, filtering, or mapping operation as the JVM is capable of doing. These are found in the low-level namespace <a href="https://cnuernber.github.io/dtype-next/tech.v3.parallel.for.html">tech.v3.parallel.for</a>.</p>
<ul>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.parallel.for.html#var-indexed-map-reduce">indexed-map-reduce</a> - Efficiently iterate over a range of integer indexes. Indexes are traversed in order in a few of parallelization groups as possible and optionally reduce with the provided reducer. This simple design attempts to ensure the minimal parallelization overhead along with giving the underlying hardware the best possible chance to predict the next bit of data that will be accessed. Callers can create stack variables for summations and aggregations leading to a high chance of auto-vectorization for primitive operations.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.parallel.for.html#var-spliterator-map-reduce">spliterator-map-reduce</a> - A similer design to indexed map reduce to be used in situations (such as iterating over HashMap buckets) where indexed-map-reduce cannot be used. Spliterators are slightly more general than indexes and tend to work in value space as opposed to index space making accessing multiple data sources such as columns of a dataset more expensive. They are, however, much more general and allow filter steps to be done with abstraction to the caller’s reduction mechanism.</li>
</ul>
<h2><a href="#nd-tensor-operations" name="nd-tensor-operations"></a>ND/Tensor Operations</h2>
<p>The <a href="https://cnuernber.github.io/dtype-next/tech.v3.tensor.html">tech.v3.tensor</a> namespace forms the basis of ND support built on the primitives above with the addition of an index operator, the <code>dimensions</code> namespace that allows efficient index-space permutations of the above buffers. <code>dtype-next</code> is ND aware in that the elemwise operations exposed in <code>tech.v3.datatype.functional</code> work on tensors although at this point broadcasting is manually required. Tensor implement the java NDBuffer interface so low level code can use typesafe operations to perform efficient mutations and aggregations built on tensors. Tensor also implement Clojure’s IObj interface allowing them to work with <code>meta</code>, <code>with-meta</code>, and <code>vary-meta</code>.</p>
<p><code>dtype-next</code> is row-major. The <code>-&gt;buffer</code> function, when applied to tensors, gives you a row-major linearly indexed representation of the tensor. This means that images are stored natively and linearly indexing the tensor will be most efficient if the data is row-wise accessed – all of which is designed to pair with indexed-map-reduce.</p>
<p>Put another way, given a Y rows by X columns buffered image the most efficient general way to access the data is iterating over X in the inner loop. The <code>-&gt;buffer</code> function linearizes access in just this way.</p>
<p>These functions are found in the <code>tech.v3.tensor</code> namespace. Note that there are extension namespaces to allow zero-copy access to <a href="https://cnuernber.github.io/dtype-next/tech.v3.libs.buffered-image.html">buffered images</a> and <a href="https://cnuernber.github.io/dtype-next/tech.v3.libs.neanderthal.html">neanderthal matrixes</a>.</p>
<h3><a href="#creation" name="creation"></a>Creation</h3>
<ul>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.tensor.html#var--.3Etensor">-&gt;tensor</a> - Create a new tensor copying data. Optionally specify datatype and  container type.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.tensor.html#var-new-tensor">new-tensor</a> - Create a new concrete tensor of zeros of a given shape.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.tensor.html#var-ensure-tensor">ensure-tensor</a> - Attempt a zero-copy conversion falling back to -&gt;tensor when  zero-copy is not available.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.tensor.html#var-native-tensor">native-tensor</a> - Create a native-heap-based tensor.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.tensor.html#var-ensure-native">ensure-native</a> - If input is not native-heap-based, create a new tensor else return  input.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.tensor.html#var-reshape">reshape</a> - Reshape any buffer-able object into a tensor of a given shape.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.tensor.html#var-compute-tensor">compute-tensor</a> - Create a new N-dimensional tensor via a function that takes N  long integer index arguments and returns a value. The tensor definition is lazy - the function is called upon read of the value. For this reason to make  a compute tensor concrete <code>tech.v3.datatype/clone</code> may be used.</li>
</ul>
<h3><a href="#manipulation" name="manipulation"></a>Manipulation</h3>
<p>NDBuffers implement Indexed and IFn allowing them to be destructured on their outermost dimension and allowing a default slicing operation to happen if the number of integer arguments to their IFn interface is less than the number of dimensions.</p>
<ul>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.tensor.html#var-select">select</a> - select a subrect of data. Dimension-indexes can be specified via the  keyword <code>:all</code>, a clojure range, or a convertible-to-long-reader object. This can be  used to crap an image or to do reorderings such as imagespace bga-&gt;rgb conversions.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.tensor.html#var-transpose">transpose</a> - Generic in-place transpose dimensions to implement operations of the  type <code>i,j,k</code> -&gt; <code>k,j,i</code> for all orderings of <code>i,j,k</code>. This can be used, for instance, to convert  between channels-first planar representation of an image (2d planes of r,g,b,a) to a  standard rgba-interleaved representation of an image.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.tensor.html#var-reshape">reshape</a> - Reshape a tensor via interpreting it as -&gt;buffer and applying a new  dimension object. Can be used to in-place create a tensor out of a persisent  vector.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.tensor.html#var-broadcast">broadcast</a> - Create a larger read-only tensor via repeating one or more dimensions.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.tensor.html#var-slice">slice</a>, <a href="https://cnuernber.github.io/dtype-next/tech.v3.tensor.html#var-slice-right">slice-right</a> - Create a reader formed by iterating the left/right N dimensions  in order. Given a 2D matrix, <code>(slice mat 1)</code> returns the rows while  <code>(slice-right mat 1)</code> returns the columns.</li>
</ul>
<h3><a href="#zero-copy-integrations" name="zero-copy-integrations"></a>Zero-Copy Integrations</h3>
<p>Native heap backed tensor allow zero-copy conversions between systems such as numpy and julia. Implementing zero-copy is fairly straight-forward as the shared ABI is:</p>
<pre><code class="clojure">#{:ptr ;; long ptr
  :elemwise-datatype ;; Datatype of buffer
  :shape ;; integer shape
  :strides ;; integer byte-wise per-dimension strides}
</code></pre>
<ul>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.tensor.html#var-nd-buffer-descriptor-.3Etensor">nd-buffer-descriptor-&gt;tensor</a> - given an ND buffer descriptor, return a tensor.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.tensor.html#var-ensure-nd-buffer-descriptor">ensure-nd-buffer-descriptor</a> - check if a given tensor  supports zero-copy conversion to an nd buffer descriptor and perform that  conversion. Else copy tensor into a suitable buffer and create descriptor.</li>
</ul>
<h2><a href="#datetime-support" name="datetime-support"></a>Datetime Support</h2>
<p>Datetime support is divided into useful type-hinted long constants, a set of scalar functions to create and transform particular datetime types and a small set of vectorized functions that can work on readers of datetime datatypes.</p>
<p>Scalar constructors are named after the type they construct and type hinted with their return value.</p>
<p>All of the functions below are found in the <a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.datetime.html">tech.v3.datatype.datetime</a> namespace. If the function is marked with <code>vectorized</code> then it can work on readers and scalars in a similar vein as <code>+</code> in the functional namespace.</p>
<ul>
  <li><code>nanoseconds-in-*</code>, <code>milliseconds-in-*</code>, <code>seconds-in-*</code> - Type hinted constants to make numeric conversions easier.</li>
  <li><code>local-date</code>, <code>local-date-time</code>, <code>zoned-date-time</code>, <code>instant</code> - Scalar constructors of specific java.time types.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.datetime.html#var-plus-temporal-amount">plus-temporal-amount</a>, <a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.datetime.html#var-minus-temporal-amount">minus-temporal-amount</a> - <code>vectorized</code> - add/subtract a temporal amount returning a new datetime object or reader.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.datetime.html#var-between">between</a> - <code>vectorized</code> - Find the amount of time between two datetime objects or readers of datetime objects.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.datetime.html#var-datetime-.3Eepoch">datetime-&gt;epoch</a>, <a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.datetime.html#var-epoch-.3Edatetime">epoch-&gt;datetime</a> - <code>vectorized</code> - convert to an epoch datatype such as milliseconds-since-epoch.</li>
  <li><a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.datetime.html#var-long-temporal-field">long-temporal-field</a> - <code>vectorized</code> - Return a specific temporal field such as :days-since-epoch from a datetime type or a reader of datetime types.</li>
</ul></div></div></div></body></html>