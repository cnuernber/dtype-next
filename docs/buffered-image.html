<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Buffered Image Support</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">dtype-next</span> <span class="project-version">6.01</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="buffered-image.html"><div class="inner"><span>Buffered Image Support</span></div></a></li><li class="depth-1 "><a href="cheatsheet.html"><div class="inner"><span>Cheatsheet</span></div></a></li><li class="depth-1 "><a href="datatype-to-dtype-next.html"><div class="inner"><span>Why dtype-next?</span></div></a></li><li class="depth-1 "><a href="dimensions-bytecode-gen.html"><div class="inner"><span>Dimensions and Bytecode Generation</span></div></a></li><li class="depth-1 "><a href="overview.html"><div class="inner"><span>Overview</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tech</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>v3</span></div></div></li><li class="depth-3"><a href="tech.v3.datatype.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>datatype</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.argops.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>argops</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.bitmap.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bitmap</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.datetime.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>datetime</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.errors.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>errors</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.ffi.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ffi</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.functional.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>functional</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.jna.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jna</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.list.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>list</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.mmap.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mmap</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.mmap-writer.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mmap-writer</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.native-buffer.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>native-buffer</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.nippy.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>nippy</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.packing.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>packing</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.reductions.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>reductions</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.rolling.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rolling</span></div></a></li><li class="depth-4"><a href="tech.v3.datatype.struct.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>struct</span></div></a></li><li class="depth-3"><div class="no-link"><div class="inner"><span class="tree" style="top: -517px;"><span class="top" style="height: 526px;"></span><span class="bottom"></span></span><span>libs</span></div></div></li><li class="depth-4 branch"><a href="tech.v3.libs.buffered-image.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>buffered-image</span></div></a></li><li class="depth-4"><a href="tech.v3.libs.neanderthal.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>neanderthal</span></div></a></li><li class="depth-3"><div class="no-link"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>parallel</span></div></div></li><li class="depth-4"><a href="tech.v3.parallel.for.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>for</span></div></a></li><li class="depth-3"><a href="tech.v3.tensor.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>tensor</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.tensor.color-gradients.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>color-gradients</span></div></a></li><li class="depth-4"><a href="tech.v3.tensor.dimensions.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dimensions</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#buffered-image-support" name="buffered-image-support"></a>Buffered Image Support</h1>
<p><code>dtype-next</code> contains support for loading/saving buffered images and creating tensors from buffered images.</p>
<h2><a href="#usage" name="usage"></a>Usage</h2>
<p>Buffered images implement the protocols required to be part of the datatype system.</p>
<h3><a href="#basics" name="basics"></a>Basics</h3>
<pre><code class="clojure">user&gt; (require '[tech.v3.libs.buffered-image :as bufimg])
nil
user&gt; (bufimg/load "https://raw.githubusercontent.com/cnuernber/dtype-next/master/test/data/test.jpg")
#object[java.awt.image.BufferedImage 0x579ce3c2 "BufferedImage@579ce3c2: type = 5 ColorModel: #pixelBits = 24 numComponents = 3 color space = java.awt.color.ICC_ColorSpace@5bd9ef6d transparency = 1 has alpha = false isAlphaPre = false ByteInterleavedRaster: width = 512 height = 288 #numDataElements 3 dataOff[0] = 2"]
user&gt; (def test-img *1)
#'user/test-img
user&gt; (require '[tech.v3.datatype :as dtype])
nil
user&gt; (dtype/elemwise-datatype test-img)
:uint8
user&gt; (dtype/shape test-img)
[288 512 3]
user&gt; (bufimg/image-channel-format test-img)
:bgr
user&gt; (require '[tech.v3.tensor :as dtt])
nil

;;Tensors implement a set of interfaces such as Indexed and IFn.  In most cases those interfaces
;;allow you to either read or write to a subrect of the tensor.

user&gt; (def tens (dtt/ensure-tensor test-img))
user&gt; ;;nth indexes into the first dimension.
user&gt; (nth tens 0)
#tech.v3.tensor&lt;uint8&gt;[512 3]
[[172 170 170]
 [172 170 170]
 [171 169 169]
 ...
 [ 24  18  23]
 [ 24  18  23]
 [ 24  18  23]]
user&gt; ;;IFn indexes into provided dimensions
user&gt; (tens 0)
#tech.v3.tensor&lt;uint8&gt;[512 3]
[[172 170 170]
 [172 170 170]
 [171 169 169]
 ...
 [ 24  18  23]
 [ 24  18  23]
 [ 24  18  23]]
user&gt; (tens 0 0)
#tech.v3.tensor&lt;uint8&gt;[3]
[172 170 170]
user&gt; (tens 0 0 0)
172
</code></pre>
<ul>
  <li>One important thing to note is the return value of ensure-tensor shares the backing data store with the source object. So you can write to the tensor with any of the datatype methods and the result will be written into the buffered image.</li>
</ul>
<pre><code class="clojure">user&gt; ;;mget, mset! allow you to retrieve/assign values to subrects (or scalars)
user&gt; (dtt/mget tens 0 0)
#tech.v3.tensor&lt;uint8&gt;[3]
[172 170 170]
user&gt; (dtt/mset! tens 0 0 0 255)
#tech.v3.tensor&lt;uint8&gt;[288 512 3]
[[[255 170 170]
  [172 170 170]
  [171 169 169]
  ...
  [ 24  18  23]
  [ 24  18  23]
  [ 24  18  23]]
  ...
user&gt; (dtt/mget (dtt/ensure-tensor test-img) 0 0 0)
255
user&gt; (dtt/mset! tens 0 0 [255 245 235])
#tech.v3.tensor&lt;uint8&gt;[288 512 3]
[[[255 245 235]
  [172 170 170]
  [171 169 169]
  ...
  [ 24  18  23]
  [ 24  18  23]
  [ 24  18  23]]
</code></pre>
<h3><a href="#different-image-types" name="different-image-types"></a>Different Image Types</h3>
<pre><code class="clojure"><br />;;If you have images of other base storage types you may get a different tensor than
;;you want:

user&gt; (vec (keys bufimg/image-types))
[:int-bgr
 :byte-gray
 :byte-binary
 :ushort-gray
 :ushort-555-rgb
 :int-argb-pre
 :byte-indexed
 :custom
 :byte-bgr
 :byte-abgr-pre
 :int-rgb
 :ushort-565-rgb
 :byte-abgr
 :int-argb]


user&gt; (def test-img (bufimg/new-image 4 4 :int-bgr))
#'user/test-img
user&gt; (dtt/ensure-tensor test-img)
#tech.v3.tensor&lt;int32&gt;[4 4 1]
[[[0]
  [0]
  [0]
  [0]]
 [[0]
  [0]
  [0]
  [0]]
 [[0]
  [0]
  [0]
  [0]]
 [[0]
  [0]
  [0]
  [0]]]

;;So we have a convenience method that will always return a uint8 tensor:

user&gt; (bufimg/as-ubyte-tensor test-img)
#tech.v3.tensor&lt;uint8&gt;[4 4 3]
[[[0 0 0]
  [0 0 0]
  [0 0 0]
  [0 0 0]]
 [[0 0 0]
  [0 0 0]
  [0 0 0]
  [0 0 0]]
 [[0 0 0]
  [0 0 0]
  [0 0 0]
  [0 0 0]]
 [[0 0 0]
  [0 0 0]
  [0 0 0]
  [0 0 0]]]
</code></pre>
<h3><a href="#tensor-operations" name="tensor-operations"></a>Tensor Operations</h3>
<p>All the tensor operations return data in-place. So in the transpose call below a view is returned without actually doing any copies. Iterating over tensors iterates over the outermost dimension returning a sequence of tensors or a sequence of numbers if this is a one dimension tensor.</p>
<p>Our image is in BGR-interleaved format, so what we first do is transpose the image into BGR planar format. We then use the statistical methods in datatype in order to get the per-channel statistics for the image.</p>
<pre><code class="clojure"><br />;;Having images be tensors is useful for a few things, but stats is one of them.
user&gt; (def test-img (bufimg/load "https://raw.githubusercontent.com/cnuernber/dtype-next/master/test/data/test.jpg"))
#'user/test-img
user&gt; (def planar-tens (dtt/transpose test-img [2 0 1]))
#'user/planar-tens
user&gt; planar-tens
#tech.v3.tensor&lt;uint8&gt;[3 288 512]
[[[172 172 171 ... 24 24 24]
  [173 174 173 ... 23 23 23]
  [174 175 174 ... 23 22 22]
  ...
  [ 37  37  37 ... 55 54 55]
  [ 36  35  35 ... 52 50 53]
  [ 39  37  34 ... 51 49 53]]
 [[170 170 169 ... 18 18 18]
  [171 172 171 ... 17 17 17]
  [172 173 172 ... 17 16 16]
  ...
  [ 46  46  46 ... 51 50 51]
  [ 45  44  44 ... 51 49 52]
  [ 48  46  43 ... 50 48 52]]
 [[170 170 169 ... 23 23 23]
  [171 172 171 ... 22 22 22]
  [172 173 172 ... 22 21 21]
  ...
  [ 84  84  83 ... 56 55 56]
  [ 83  82  81 ... 55 53 56]
  [ 86  84  80 ... 54 52 56]]]


user&gt; (map dfn/descriptive-statistics planar-tens)
({:min 0.0,
  :mean 97.47846137152777,
  :standard-deviation 60.73587071027433,
  :max 248.0,
  :n-values 147456}
 {:min 5.0,
  :mean 101.00441487630208,
  :standard-deviation 58.55138215866232,
  :max 255.0,
  :n-values 147456}
 {:min 5.0,
  :mean 113.43905978732639,
  :standard-deviation 57.797302391956244,
  :max 255.0,
  :n-values 147456})
</code></pre>
<h3><a href="#cropping-resizing-images" name="cropping-resizing-images"></a>Cropping/Resizing Images</h3>
<p>For simple resize operations, we provide a resize convenience function that uses the buffered image graphics canvas to render a resized image into another image.</p>
<p>Cropping can be done 2 ways. The draw-image! method can crop or you can select regions of the images using the tensor api and then us the datatype copy! operation.</p>
<pre><code class="clojure">;;Drawing images work well in order to copy parts of one:
(def new-img (bufimg/new-image 512 512 :int-argb))
#'user/new-img
user&gt; (bufimg/draw-image! test-img new-img :dst-y-offset 128)
#object[java.awt.image.BufferedImage 0x1ec0f94c "BufferedImage@1ec0f94c: type = 2 DirectColorModel: rmask=ff0000 gmask=ff00 bmask=ff amask=ff000000 IntegerInterleavedRaster: width = 512 height = 512 #Bands = 4 xOff = 0 yOff = 0 dataOffset[0] 0"]
</code></pre>
<h3><a href="#api-reference" name="api-reference"></a>API Reference</h3>
<ul>
  <li><code>load</code> - load an image. clojure.java.io/input-stream is called on the fname.</li>
  <li><code>new-image</code> - Create a new image. Arguments are in row-major format:  height,width,img-type.</li>
  <li><code>image-type</code> - Returns the image type of the image.</li>
  <li><code>image-channel-map</code> - Returns a map of the channel names to indexes when the image  is interpreted as a uint8 tensor.</li>
  <li><code>as-ubyte-tensor</code> - interpret image as a uint8 tensor. Works for byte and int image types.</li>
  <li><code>draw-image!</code> - Draw a source image onto a dest image. You can specify the  source/dest rectangles and an interpolation method when resizing.</li>
  <li><code>downsample-bilinear</code> - Convenience method around <code>draw-image</code>. Default is to halve  the height and width of the image.</li>
  <li><code>resize</code> - Convenience method that auto-determines the interpolation type based on  source/dest width ratio.</li>
  <li><code>clone</code> - Clone an image. Simply calls <code>tech.v2.datatype/clone</code>.</li>
  <li><code>save!</code> - save the image. You can specify a format optionally aside from the fname  or it will be inferred from the part of the fname following the last ‘.’.</li>
</ul>
<p>It is important to note that all of the datatype methods work on the image - <code>ecount</code>, <code>shape</code>, <code>elemwise-datatype</code>, <code>copy!</code>, <code>set-constant!</code>. All of the tensor methods work on the image - <code>ensure-tensor</code>, <code>select</code>, <code>reshape</code>, <code>transpose</code>. You can create a tensor reader or writer from the image to get fully typed access to it in height,width,channel as demonstrated above.</p></div></div></div></body></html>