<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Why dtype-next?</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">dtype-next</span> <span class="project-version">6.01</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="buffered-image.html"><div class="inner"><span>Buffered Image Support</span></div></a></li><li class="depth-1 "><a href="cheatsheet.html"><div class="inner"><span>Cheatsheet</span></div></a></li><li class="depth-1  current"><a href="datatype-to-dtype-next.html"><div class="inner"><span>Why dtype-next?</span></div></a></li><li class="depth-1 "><a href="dimensions-bytecode-gen.html"><div class="inner"><span>Dimensions and Bytecode Generation</span></div></a></li><li class="depth-1 "><a href="overview.html"><div class="inner"><span>Overview</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tech</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>v3</span></div></div></li><li class="depth-3"><a href="tech.v3.datatype.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>datatype</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.argops.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>argops</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.bitmap.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bitmap</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.datetime.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>datetime</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.errors.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>errors</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.ffi.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ffi</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.functional.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>functional</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.jna.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jna</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.list.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>list</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.mmap.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mmap</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.mmap-writer.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mmap-writer</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.native-buffer.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>native-buffer</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.nippy.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>nippy</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.packing.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>packing</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.reductions.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>reductions</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.datatype.rolling.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rolling</span></div></a></li><li class="depth-4"><a href="tech.v3.datatype.struct.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>struct</span></div></a></li><li class="depth-3"><div class="no-link"><div class="inner"><span class="tree" style="top: -517px;"><span class="top" style="height: 526px;"></span><span class="bottom"></span></span><span>libs</span></div></div></li><li class="depth-4 branch"><a href="tech.v3.libs.buffered-image.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>buffered-image</span></div></a></li><li class="depth-4"><a href="tech.v3.libs.neanderthal.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>neanderthal</span></div></a></li><li class="depth-3"><div class="no-link"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>parallel</span></div></div></li><li class="depth-4"><a href="tech.v3.parallel.for.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>for</span></div></a></li><li class="depth-3"><a href="tech.v3.tensor.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>tensor</span></div></a></li><li class="depth-4 branch"><a href="tech.v3.tensor.color-gradients.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>color-gradients</span></div></a></li><li class="depth-4"><a href="tech.v3.tensor.dimensions.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dimensions</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#why-dtype-next-" name="why-dtype-next-"></a>Why dtype-next?</h1>
<h2><a href="#tech-datatype" name="tech-datatype"></a>tech.datatype</h2>
<p>tech.datatype as a numerics stack fulfills our technical needs at TechAscent in regards to scientific computing, data science, and machine learning. It enables a completely unified interface between native heap and JVM heap datastructures with a base level of datatype support and various simple accelerated operations.</p>
<p>In order to fulfill unified support for efficient random access across many datatypes it uses many type specific constructions that enable primitive reading/writing to buffers with disparate storage backends.</p>
<p>One drawback of this style of implementaion is an explosion of compile-time interfaces; interfaces that efficiently allow, for example, reading or writing a primitive double at a particular address in the buffer. On top of this is a marshalling stack, so roughly n^2 implementation of type transformations from, for example, float to integer. Each operation, such as <code>+</code> or <code>indexed-reader</code>, is specialized to precisely one datatype with a specific interface implementation for each specialization.</p>
<p>These small specialization classes end up having a disproportionately high cost in terms of both uberjar size and in terms of application startup time; essentially the compile time programming to specialize things to a specific datatype is costly at require time <em>even with AOT</em>. Just the classloader time required to load the class explosion caused by the roughly cartesian join of Y operations by X classes is substantial not to mention the understanding of compile time programming required to efficiently generate specializations of new operations.</p>
<p>What this design <em>did</em> achieve, however, was substantial generalized performance as exhibited in our professional engagements of the type that is very expensive to achieve with any JVM language. It also enabled the efficient integration with tools such as TVM, Numpy, and the creation of a dataframe library with competitive performance with C toolkits.</p>
<h2><a href="#towards-a-different-implementation-pathway" name="towards-a-different-implementation-pathway"></a>Towards A Different Implementation Pathway</h2>
<p>The problem is specifically how to implement type specific code that is both efficient in runtime <em>and</em> compile time performance. Having achieved runtime performance now it is time to focus on compile time performance. We want to produce the same result with less code both in implementation and far smaller overall compile time results in this case those results relate nearly directly to time to intial use which is important in specific key use cases.</p>
<p>There are a few pathways to this result but the one that appears to have the most potential is a simple one. If, instead of a reader implementing only one type-specific read method, readers implemented every type specific read method with default casting rules between the primitive datatypes we can actually, for the same implementation cost as measured by the cost to implement a reader of a particular datatype, gain identical performance with far more runtime flexibility resulting in less need in the first place for compile time case statements generating the explosion of small classes that bloat both require time and uberjar size.</p>
<p>Here is an example. In tech.datatype, a DoubleReader implements a single read method that reads a long at a particular address:</p>
<pre><code class="java">public interface DoubleReader
{
  long lsize();
  double read(long idx);
}
</code></pre>
<p>In dtype-next there exists a new concept called a Buffer:</p>
<pre><code class="java">public interface Buffer extends IOBase, Iterable, IFn,
				             List, RandomAccess, Sequential,
                             Indexed
{
  boolean readBoolean(long idx);
  byte readByte(long idx);
  short readShort(long idx);
  char readChar(long idx);
  int readInt(long idx);
  long readLong(long idx);
  float readFloat(long idx);
  double readDouble(long idx);
  Object readObject(long idx);
  void writeBoolean(long idx, boolean val);
  void writeByte(long idx, byte val);
  void writeShort(long idx, short val);
  void writeChar(long idx, char val);
  void writeInt(long idx, int val);
  void writeLong(long idx, long val);
  void writeFloat(long idx, float val);
  void writeDouble(long idx, double val);
  void writeObject(long idx, Object val);
  default boolean allowsRead() { return true; }
  default boolean allowsWrite() { return false; }
  //Lots of implementation of the above interfaces based on these methods.
  ...
}
</code></pre>
<p>With this concept in mind, a DoubleIO implements this interface using a combination of checked runtime casting and the original <code>double read(long idx)</code> method:</p>
<pre><code class="java">public interface DoubleIO extends Buffer
{
  default Object elemwiseDatatype () { return Keyword.intern(null, "float64"); }
  default boolean readBoolean(long idx) {return readDouble(idx) != 0.0;}
  default byte readByte(long idx) {return RT.byteCast(readDouble(idx));}
  default short readShort(long idx) {return RT.byteCast(readDouble(idx));}
  default char readChar(long idx) {return RT.charCast(readDouble(idx));}
  default int readInt(long idx) {return RT.intCast(readDouble(idx));}
  default long readLong(long idx) {return RT.longCast(readDouble(idx));}
  default float readFloat(long idx) {return (float)readDouble(idx);}
  default Object readObject(long idx) {return readDouble(idx);}

  //Write interaces implemented below
  ...
}
</code></pre>
<p>This means we don’t need to create a specific reader to convert a double reader into a long reader. Thus we no longer have a cartesian join of required interfaces but rather we have ‘wider’ default interface implementations.</p>
<p>For many situations, due to the wider interfaces, we can now implement 1 interface with many methods as opposed to many interfaces with 1 method.</p>
<h2><a href="#additional-optimizations" name="additional-optimizations"></a>Additional Optimizations</h2>
<p>Java classes have to be a minimum of 4K in size regardless of the amount of code required to implement them and they grow in 4K amounts. A back-of-the-hand measurement indicated that loading more classes was relatively more expensive than loading a few, larger classes.</p>
<p>Knowing this, we can slowly move out in the datatype world being extremely careful at each step to only generate classes where it is essential for either performance or correctness. Here are a set of further optimizations found so far:</p>
<ul>
  <li>Buffer-specific implementations are mimimized and buffer’s implement a single class that provides the Buffer implementation. For example there is a single class implementation that provides typesafe access to byte buffers and another that provides typesafe access for byte buffers that are to be interpreted as unsigned byte data. That cuts out half the implementations of readers and writers.</li>
  <li>There can be a single const-reader implementation as opposed to N implementations, one for each datatype. Ditto for indexed Buffer implementations which are one of the most heavily used items in tech.datatype.</li>
  <li>The arithmetic math vectorization implementation implements 3 overloads - one for double, one for long, and one for object.</li>
  <li>The + operator implements one class. In tech.datatype it implemented a class for each individual numeric datatype plus one override for Object.</li>
</ul>
<h2><a href="#benchmarks" name="benchmarks"></a>Benchmarks</h2>
<h3><a href="#api-require-time-no-aot" name="api-require-time-no-aot"></a>API Require Time - No AOT</h3>
<pre><code class="clojure">user&gt; (time (require 'tech.v2.datatype))
"Elapsed time: 6752.785449 msecs"
nil
</code></pre>
<pre><code class="clojure">user&gt; (time (require 'tech.v3.datatype))
"Elapsed time: 2142.680631 msecs"
nil
</code></pre>
<h3><a href="#tensor-require-time-no-aot" name="tensor-require-time-no-aot"></a>Tensor Require time - No AOT</h3>
<pre><code class="clojure">user&gt; (time (require 'tech.v2.tensor))
"Elapsed time: 8696.394848 msecs"
nil
</code></pre>
<pre><code class="clojure">user&gt; (time (require 'tech.v3.tensor))
"Elapsed time: 3516.401243 msecs"
nil
</code></pre>
<h3><a href="#api-require-time-with-aot" name="api-require-time-with-aot"></a>API Require Time - With AOT</h3>
<pre><code class="clojure">user&gt; (time (require 'tech.v2.datatype))
"Elapsed time: 1231.607731 msecs"
nil
</code></pre>
<pre><code class="clojure">user&gt; (time (require 'tech.v3.datatype))
"Elapsed time: 525.53414 msecs"
nil
</code></pre>
<h3><a href="#tensor-require-time-with-aot" name="tensor-require-time-with-aot"></a>Tensor Require Time - With AOT</h3>
<pre><code class="clojure">user&gt; (time (require 'tech.v2.tensor))
"Elapsed time: 1478.459059 msecs"
nil
</code></pre>
<pre><code class="clojure">user&gt; (time (require 'tech.v3.tensor))
"Elapsed time: 713.795019 msecs"
nil
</code></pre>
<h3><a href="#tech-platform-aot-uberjar-size" name="tech-platform-aot-uberjar-size"></a>Tech Platform AOT Uberjar Size</h3>
<pre><code class="console">chrisn@chrisn-lt-01:~/dev/tech.all/tech.datatype$ du -hs target/classes/tech
26M     target/classes/tech
</code></pre>
<pre><code class="console">chrisn@chrisn-lt-01:~/dev/cnuernber/dtype-next$ du -hs target/classes/tech
9.1M    target/classes/tech
</code></pre></div></div></div></body></html>